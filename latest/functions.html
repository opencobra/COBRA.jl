<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modules and Functions · COBRA.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script></head><body><nav class="toc"><a href><img class="logo" src="assets/logo.png" alt="COBRA.jl logo"/></a><h1>COBRA.jl</h1><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">COBRA.jl - COnstraint-Based Reconstruction and Analysis</a></li><li><a class="toctext" href="cbg.html">Complete Beginner&#39;s Guide</a></li><li><a class="toctext" href="cobratutorial.html">Tutorial</a></li><li><a class="toctext" href="configuration.html">Configuration</a></li><li class="current"><a class="toctext" href="functions.html">Modules and Functions</a><ul class="internal"><li><a class="toctext" href="#connect.jl-1">connect.jl</a></li><li><a class="toctext" href="#checkSetup.jl-1">checkSetup.jl</a></li><li><a class="toctext" href="#distributedFBA.jl-1">distributedFBA.jl</a></li><li><a class="toctext" href="#load.jl-1">load.jl</a></li><li><a class="toctext" href="#solve.jl-1">solve.jl</a></li></ul></li><li><a class="toctext" href="faq.html">FAQ</a></li><li><a class="toctext" href="contents.html">Index</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="functions.html">Modules and Functions</a></li></ul><a class="edit-page" href="https://github.com/opencobra/COBRA.jl/tree/0d867c7d7dff7a60150da3f3408fdd0207335aae/docs/src/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><h2><a class="nav-anchor" id="connect.jl-1" href="#connect.jl-1">connect.jl</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="createPool" href="#createPool"><code>createPool</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">createPool(localWorkers, connectSSHWorkers)</code></pre><p>Function used to create a pool of parallel workers that are either local or connected via SSH.</p><p><strong>INPUTS</strong></p><ul><li><p><code>localWorkers</code>:   Number of local workers to connect.                   If <code>connectSSH</code> is <code>true</code>, the number of localWorkers is 1 (host).</p></li></ul><p><strong>OPTIONAL INPUTS</strong></p><ul><li><p><code>connectSSH</code>:     Boolean that indicates whether additional nodes should be connected via SSH.                   (default: <code>false</code>)</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>workers()</code>:      Array of IDs of the connected workers (local and SSH workers)</p></li><li><p><code>nWorkers</code>:       Total number of connect workers (local and SSH workers)</p></li></ul><p><strong>EXAMPLES</strong></p><p>Minimum working example:</p><pre><code class="language-julia">julia&gt; createPool(localWorkers)</code></pre><p>See also: <code>workers()</code>, <code>nprocs()</code>, <code>addprocs()</code>, <code>gethostname()</code></p></div><a class="source-link" target="_blank" href="https://github.com/opencobra/COBRA.jl/tree/0d867c7d7dff7a60150da3f3408fdd0207335aae/docs/../src/connect.jl#L9-L38">source</a><br/></section><h2><a class="nav-anchor" id="checkSetup.jl-1" href="#checkSetup.jl-1">checkSetup.jl</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="checkPackage" href="#checkPackage"><code>checkPackage</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">checkPackage(pkgname)</code></pre><p>Function checks whether a package is installed properly or not and returns a boolean value.</p><p><strong>INPUTS</strong></p><ul><li><p><code>pkgname</code>:        A string that contains the name of the package to be checked</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p>(bool):           A boolean that indicates whether a package is installed properly</p></li></ul><p>See also: <code>using</code>, <code>isdir()</code></p></div><a class="source-link" target="_blank" href="https://github.com/opencobra/COBRA.jl/tree/0d867c7d7dff7a60150da3f3408fdd0207335aae/docs/../src/checkSetup.jl#L9-L24">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="checkSysConfig" href="#checkSysConfig"><code>checkSysConfig</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">checkSysConfig()</code></pre><p>Function evaluates whether the LP solvers of MathProgBase are installed on the system or not and returns a list of these packages. <code>MathProgBase.jl</code> must be installed.</p><p><strong>OUTPUTS</strong></p><ul><li><p>packages:         A list of solver packages installed on the system</p></li></ul><p>See also: <code>MathProgBase</code>, <code>checkPackage()</code></p></div><a class="source-link" target="_blank" href="https://github.com/opencobra/COBRA.jl/tree/0d867c7d7dff7a60150da3f3408fdd0207335aae/docs/../src/checkSetup.jl#L48-L60">source</a><br/></section><h2><a class="nav-anchor" id="distributedFBA.jl-1" href="#distributedFBA.jl-1">distributedFBA.jl</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="preFBA!" href="#preFBA!"><code>preFBA!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">preFBA!(model, solver, optPercentage, osenseStr, rxnsList)</code></pre><p>Function that solves the original FBA, adds the objective value as a constraint to the stoichiometric matrix of the model, and changes the RHS vector <code>b</code>. Note that the <code>model</code> object is changed.</p><p><strong>INPUTS</strong></p><ul><li><p><code>model</code>:          An <code>::LPproblem</code> object that has been built using the <code>loadModel</code> function.                       All fields of <code>model</code> must be available.</p></li><li><p><code>solver</code>:         A <code>::SolverConfig</code> object that contains a valid <code>handle</code> to the solver</p></li></ul><p><strong>OPTIONAL INPUTS</strong></p><ul><li><p><code>optPercentage</code>:  Only consider solutions that give you at least a certain percentage of the optimal solution (default: 100%)</p></li><li><p><code>osenseStr</code>:      Sets the optimization mode of the original FBA (&quot;max&quot; or &quot;min&quot;, default: &quot;max&quot;)</p></li><li><p><code>rxnsList</code>:       List of reactions to analyze (default: all reactions)</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>objValue</code>:       Optimal objective value of the original FBA problem</p></li><li><p><code>fbaSol</code>:         Solution vector that corresponds to the optimal objective value</p></li></ul><p><strong>EXAMPLES</strong></p><ul><li><p>Minimum working example:</p></li></ul><pre><code class="language-julia">julia&gt; preFBA!(model, solver)</code></pre><ul><li><p>Full input/output example</p></li></ul><pre><code class="language-julia">julia&gt; optSol, fbaSol = preFBA!(model, solver, optPercentage, objective)</code></pre><p>See also: <code>solveCobraLP()</code>, <code>distributedFBA()</code></p></div><a class="source-link" target="_blank" href="https://github.com/opencobra/COBRA.jl/tree/0d867c7d7dff7a60150da3f3408fdd0207335aae/docs/../src/distributedFBA.jl#L9-L46">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="splitRange" href="#splitRange"><code>splitRange</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">splitRange(model, rxnsList, nWorkers, strategy)</code></pre><p>Function splits a reaction list in blocks for a certain number of workers according to a selected strategy. Generally , <code>splitRange()</code> is called before the FBAs are distributed.</p><p><strong>INPUTS</strong></p><ul><li><p><code>model</code>:          An <code>::LPproblem</code> object that has been built using the <code>loadModel</code> function.                       All fields of <code>model</code> must be available.</p></li><li><p><code>rxnsList</code>:       List of reactions to analyze (default: all reactions)</p></li></ul><p><strong>OPTIONAL INPUTS</strong></p><ul><li><p><code>nWorkers</code>:       Number of workers as initialized using <code>createPool()</code> or similar</p></li><li><p><code>strategy</code>:       Number of the splitting strategy</p><ul><li><p>0: Blind splitting: default random distribution</p></li><li><p>1: Extremal dense-and-sparse splitting: every worker receives dense and sparse reactions, starting from both extremal indices of the sorted column density vector</p></li><li><p>2: Central dense-and-sparse splitting: every worker receives dense and sparse reactions, starting from the beginning and center indices of the sorted column density vector</p></li></ul></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>rxnsKey</code>:        Structure with vector for worker <code>p</code> with start and end indices of each block</p></li></ul><p><strong>EXAMPLES</strong></p><ul><li><p>Minimum working example</p></li></ul><pre><code class="language-julia">julia&gt; splitRange(model, rxnsList, 2)</code></pre><ul><li><p>Selection of the splitting strategy 2 for 4 workers</p></li></ul><pre><code class="language-julia">julia&gt; splitRange(model, rxnsList, 4, 2)</code></pre><p>See also: <code>distributeFBA()</code></p></div><a class="source-link" target="_blank" href="https://github.com/opencobra/COBRA.jl/tree/0d867c7d7dff7a60150da3f3408fdd0207335aae/docs/../src/distributedFBA.jl#L122-L160">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="loopFBA" href="#loopFBA"><code>loopFBA</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">loopFBA(m, rxnsList, nRxns, pid, iRound, rxnsOptMode)</code></pre><p>Function used to perform a loop of a series of FBA problems using the CPLEX solver Generally, <code>loopFBA</code> is called in a loop over multiple workers and makes use of the <code>CPLEX.jl</code> module.</p><p><strong>INPUTS</strong></p><ul><li><p><code>m</code>:              A MathProgBase.LinearQuadraticModel object with <code>inner</code> field</p></li><li><p><code>solver</code>:         A <code>::SolverConfig</code> object that contains a valid <code>handle</code>to the solver</p></li><li><p><code>rxnsList</code>:       List of reactions to analyze (default: all reactions)</p></li><li><p><code>nRxns</code>:          Total number of reaction in the model <code>m.inner</code></p></li></ul><p><strong>OPTIONAL INPUTS</strong></p><ul><li><p><code>rxnsOptMode</code>:    List of min/max optimizations to perform:</p><ul><li><p>0: only minimization</p></li><li><p>1: only maximization</p></li><li><p>2: minimization &amp; maximization [default: all reactions are minimized and maximized, i.e. 2+zeros(Int,length(model.rxns))]</p></li></ul></li><li><p><code>iRound</code>:         Index of optimization round</p><ul><li><p>0: minimization</p></li><li><p>1: maximization</p></li></ul></li><li><p><code>pid</code>:            Julia ID of launched process</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>retObj</code>:         Vector with optimal (either <code>min</code> or <code>max</code>) solutions (objective values)</p></li><li><p><code>retFlux</code>:        Array of solution vectors corresponding to the vector with the optimal objective values                   (either <code>min</code> or <code>max</code>)</p></li><li><p><code>retStat</code>:        Vector with the status of the solver of each FBA (default: initialized with <code>-1</code>)</p><ul><li><p>0: LP problem is infeasible</p></li><li><p>1: LP problem is optimal</p></li><li><p>2: LP problem is unbounded</p></li><li><p>3: Solver for the LP problem has hit a user limit</p></li><li><p>4: LP problem is infeasible or unbounded</p></li><li><p>5: LP problem has a non-documented solution status</p></li></ul></li></ul><p><strong>EXAMPLES</strong></p><ul><li><p>Minimum working example</p></li></ul><pre><code class="language-julia">julia&gt; loopFBA(m, rxnsList, nRxns)</code></pre><p>See also: <code>distributeFBA()</code>, <code>MathProgBase.HighLevelInterface</code></p></div><a class="source-link" target="_blank" href="https://github.com/opencobra/COBRA.jl/tree/0d867c7d7dff7a60150da3f3408fdd0207335aae/docs/../src/distributedFBA.jl#L280-L328">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="distributedFBA" href="#distributedFBA"><code>distributedFBA</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">distributedFBA(model, solver, nWorkers, optPercentage, objective, rxnsList, strategy, preFBA, rxnsOptMode)</code></pre><p>Function to distribute a series of FBA problems across one or more workers that have been initialized using the <code>createPool</code> function (or similar).</p><p><strong>INPUTS</strong></p><ul><li><p><code>model</code>:          An <code>::LPproblem</code> object that has been built using the <code>loadModel</code> function.                       All fields of <code>model</code> must be available.</p></li><li><p><code>solver</code>:         A <code>::SolverConfig</code> object that contains a valid <code>handle</code> to the solver</p></li><li><p><code>nWorkers</code>:       Number of workers as initialized using <code>createPool()</code> or similar</p></li></ul><p><strong>OPTIONAL INPUTS</strong></p><ul><li><p><code>optPercentage</code>:  Only consider solutions that give you at least a certain percentage of the optimal solution (default: 100%)</p></li><li><p><code>objective</code>:      Objective (&quot;min&quot; or &quot;max&quot;) (default: &quot;max&quot;)</p></li><li><p><code>rxnsList</code>:       List of reactions to analyze (default: all reactions)</p></li><li><p><code>strategy</code>:       Number of the splitting strategy</p><ul><li><p>0: Blind splitting: default random distribution</p></li><li><p>1: Extremal dense-and-sparse splitting: every worker receives dense and sparse reactions, starting from both extremal indices of the sorted column density vector</p></li><li><p>2: Central dense-and-sparse splitting: every worker receives dense and sparse reactions, starting from the beginning and center indices of the sorted column density vector</p></li></ul></li><li><p><code>rxnsOptMode</code>:    List of min/max optimizations to perform:</p><ul><li><p>0: only minimization</p></li><li><p>1: only maximization</p></li><li><p>2: minimization &amp; maximization [default: all reactions are minimized and maximized, i.e. 2+zeros(Int,length(model.rxns))]</p></li></ul></li><li><p><code>preFBA</code>:         Boolean to solve the original FBA and add a percentage condition (default: true)</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>minFlux</code>:          Minimum flux for each reaction</p></li><li><p><code>maxFlux</code>:          Maximum flux for each reaction</p></li><li><p><code>optSol</code>:           Optimal solution of the initial FBA</p></li><li><p><code>fbaSol</code>:           Solution vector of the initial FBA</p></li><li><p><code>fvamin</code>:           Array with flux values for the considered reactions (minimization)</p></li><li><p><code>fvamax</code>:           Array with flux values for the considered reactions (maximization)</p></li><li><p><code>statussolmin</code>:     Vector of solution status for each reaction (minimization)</p></li><li><p><code>statussolmax</code>:     Vector of solution status for each reaction (maximization)</p></li></ul><p><strong>EXAMPLES</strong></p><ul><li><p>Minimum working example</p></li></ul><pre><code class="language-julia">julia&gt; minFlux, maxFlux = distributedFBA(model, solver)</code></pre><ul><li><p>Full input/output example</p></li></ul><pre><code class="language-julia">julia&gt; minFlux, maxFlux, optSol, fbaSol, fvamin, fvamax, statussolmin, statussolmax = distributedFBA(model, solver, optPercentage, objective, rxnsList, strategy, rxnsOptMode, true)</code></pre><p>See also: <code>preFBA!()</code>, <code>splitRange()</code>, <code>buildCobraLP()</code>, <code>loopFBA()</code>, or <code>fetch()</code></p></div><a class="source-link" target="_blank" href="https://github.com/opencobra/COBRA.jl/tree/0d867c7d7dff7a60150da3f3408fdd0207335aae/docs/../src/distributedFBA.jl#L413-L466">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="printSolSummary" href="#printSolSummary"><code>printSolSummary</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">printSolSummary(testFile::String, optSol, maxFlux, minFlux, solTime, nWorkers, solverName)</code></pre><p>Output a solution summary</p><p><strong>INPUTS</strong></p><ul><li><p><code>optSol</code>:           Optimal solution of the initial FBA</p></li><li><p><code>minFlux</code>:          Minimum flux for each reaction</p></li><li><p><code>maxFlux</code>:          Maximum flux for each reaction</p></li><li><p><code>solTime</code>:          Solution time (in seconds)</p></li><li><p><code>nWorkers</code>:         Number of workers as initialized using <code>createPool()</code> or similar</p></li><li><p><code>solverName</code>:       Name of the solver</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p>(Printed summary)</p></li></ul><p>See also: <code>norm()</code>, <code>maximum()</code>, <code>minimum()</code></p></div><a class="source-link" target="_blank" href="https://github.com/opencobra/COBRA.jl/tree/0d867c7d7dff7a60150da3f3408fdd0207335aae/docs/../src/distributedFBA.jl#L562-L582">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="saveDistributedFBA" href="#saveDistributedFBA"><code>saveDistributedFBA</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">saveDistributedFBA(fileName::String)</code></pre><p>Output a file with all the output variables of <code>distributedFBA()</code></p><p><strong>INPUTS</strong></p><ul><li><p><code>fileName</code>:         Filename of the output</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>.mat</code> file with all output variables of <code>distributedFBA()</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/opencobra/COBRA.jl/tree/0d867c7d7dff7a60150da3f3408fdd0207335aae/docs/../src/distributedFBA.jl#L600-L613">source</a><br/></section><h2><a class="nav-anchor" id="load.jl-1" href="#load.jl-1">load.jl</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LPproblem" href="#LPproblem"><code>LPproblem</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LPproblem(S, b, c, lb, ub, osense, csense, rxns, mets)</code></pre><p>General type for storing an LP problem which contains the following fields:</p><ul><li><p><code>S</code>:              LHS matrix (m x n)</p></li><li><p><code>b</code>:              RHS vector (m x 1)</p></li><li><p><code>c</code>:              Objective coefficient vector (n x 1)</p></li><li><p><code>lb</code>:             Lower bound vector (n x 1)</p></li><li><p><code>ub</code>:             Upper bound vector (n x 1)</p></li><li><p><code>osense</code>:         Objective sense (scalar; -1 ~ &quot;max&quot;, +1 ~ &quot;min&quot;)</p></li><li><p><code>csense</code>:         Constraint senses (m x 1, &#39;E&#39; or &#39;=&#39;, &#39;G&#39; or &#39;&gt;&#39;, &#39;L&#39; ~ &#39;&lt;&#39;)</p></li><li><p><code>solver</code>:         A <code>::SolverConfig</code> object that contains a valid <code>handle</code> to the solver</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/opencobra/COBRA.jl/tree/0d867c7d7dff7a60150da3f3408fdd0207335aae/docs/../src/load.jl#L9-L23">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="loadModel" href="#loadModel"><code>loadModel</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">loadModel(fileName, matrixAS, modelName)</code></pre><p>Function used to load a COBRA model from an existing .mat file</p><p><strong>INPUTS</strong></p><ul><li><p><code>filename</code>:       Name of the <code>.mat</code> file that contains the model structure</p></li></ul><p><strong>OPTIONAL INPUTS</strong></p><ul><li><p><code>matrixAS</code>:       String to distinguish the name of stoichiometric matrix (&quot;S&quot; or &quot;A&quot;, default: &quot;S&quot;)</p></li><li><p><code>modelName</code>:      String with the name of the model structure (default: &quot;model&quot;)</p></li><li><p><code>modelFields</code>:    Array with strings of fields of the model structure (default: [&quot;ub&quot;, &quot;lb&quot;, &quot;osense&quot;, &quot;c&quot;, &quot;b&quot;, &quot;csense&quot;, &quot;rxns&quot;, &quot;mets&quot;])</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>LPproblem()</code>     <code>:LPproblem</code> object with filled fields from <code>.mat</code> file</p></li></ul><p><strong>Examples</strong></p><ul><li><p>Minimum working example</p></li></ul><pre><code class="language-julia">julia&gt; loadModel(&quot;myModel.mat&quot;)</code></pre><ul><li><p>Full input/output example</p></li></ul><pre><code class="language-julia">julia&gt; model = loadModel(&quot;myModel.mat&quot;, &quot;A&quot;, &quot;myModelName&quot;, [&quot;ub&quot;,&quot;lb&quot;,&quot;osense&quot;,&quot;c&quot;,&quot;b&quot;,&quot;csense&quot;,&quot;rxns&quot;,&quot;mets&quot;]);</code></pre><p><strong>Notes</strong></p><ul><li><p><code>osense</code> is set to &quot;max&quot; (osense = -1) by default</p></li><li><p>All entries of <code>A</code>, <code>b</code>, <code>c</code>, <code>lb</code>, <code>ub</code> are of type float</p></li></ul><p>See also: <code>MAT.jl</code>, <code>matopen()</code>, <code>matread()</code></p></div><a class="source-link" target="_blank" href="https://github.com/opencobra/COBRA.jl/tree/0d867c7d7dff7a60150da3f3408fdd0207335aae/docs/../src/load.jl#L40-L77">source</a><br/></section><h2><a class="nav-anchor" id="solve.jl-1" href="#solve.jl-1">solve.jl</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverConfig" href="#SolverConfig"><code>SolverConfig</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SolverConfig(name, handle)</code></pre><p>Definition of a common solver type, which inclues the name of the solver and other parameters</p><ul><li><p><code>name</code>:           Name of the solver (alias)</p></li><li><p><code>handle</code>:         Solver handle used to refer to the solver</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/opencobra/COBRA.jl/tree/0d867c7d7dff7a60150da3f3408fdd0207335aae/docs/../src/solve.jl#L9-L17">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="buildCobraLP" href="#buildCobraLP"><code>buildCobraLP</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">buildCobraLP(model, solver)</code></pre><p>Build a model by interfacing directly with the CPLEX solver</p><p><strong>INPUTS</strong></p><ul><li><p><code>model</code>:          An <code>::LPproblem</code> object that has been built using the <code>loadModel</code> function.                       All fields of <code>model</code> must be available.</p></li><li><p><code>solver</code>:         A <code>::SolverConfig</code> object that contains a valid <code>handle</code>to the solver</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>m</code>:              A MathProgBase.LinearQuadraticModel object with <code>inner</code> field</p></li></ul><p><strong>EXAMPLES</strong></p><pre><code class="language-julia">julia&gt; m = buildCobraLP(model, solver)</code></pre><p>See also: <code>MathProgBase.LinearQuadraticModel()</code>, <code>MathProgBase.HighLevelInterface.buildlp()</code></p></div><a class="source-link" target="_blank" href="https://github.com/opencobra/COBRA.jl/tree/0d867c7d7dff7a60150da3f3408fdd0207335aae/docs/../src/solve.jl#L25-L47">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="changeCobraSolver" href="#changeCobraSolver"><code>changeCobraSolver</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">changeCobraSolver(name, params)</code></pre><p>Function used to change the solver and include the respective solver interfaces</p><p><strong>INPUT</strong></p><ul><li><p><code>name</code>:           Name of the solver (alias)</p></li></ul><p><strong>OPTIONAL INPUT</strong></p><ul><li><p><code>params</code>:         Solver parameters as a row vector with tuples</p></li></ul><p><strong>OUTPUT</strong></p><ul><li><p><code>solver</code>:         Solver object with a <code>handle</code> field</p></li></ul><p><strong>EXAMPLES</strong></p><p>Minimum working example (for the CPLEX solver)</p><pre><code class="language-julia">julia&gt; changeCobraSolver(&quot;CPLEX&quot;, cpxControl)</code></pre><p>See also: <code>MathProgBase.jl</code></p></div><a class="source-link" target="_blank" href="https://github.com/opencobra/COBRA.jl/tree/0d867c7d7dff7a60150da3f3408fdd0207335aae/docs/../src/solve.jl#L69-L94">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="solveCobraLP" href="#solveCobraLP"><code>solveCobraLP</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">solveCobraLP(model, solver)</code></pre><p>Function used to solve a linear program (LP) with a specified solver. LP problem must have the form:</p><pre><code class="language-none">                                  max/min cᵀv
                                   s.t.  Av = b
                                        l ⩽ v ⩽ u</code></pre><p><strong>INPUTS</strong></p><ul><li><p><code>model</code>:          An <code>::LPproblem</code> object that has been built using the <code>loadModel</code> function.                       All fields of <code>model</code> must be available.</p></li><li><p><code>solver</code>:         A <code>::SolverConfig</code> object that contains a valid <code>handle</code>to the solver</p></li></ul><p><strong>OUTPUTS</strong></p><ul><li><p><code>solutionLP</code>:     Solution object of type <code>LPproblem</code></p></li></ul><p><strong>EXAMPLES</strong></p><p>Minimum working example</p><pre><code class="language-julia">julia&gt; solveCobraLP(model, solver)</code></pre><p>See also: <code>MathProgBase.linprog()</code>,</p></div><a class="source-link" target="_blank" href="https://github.com/opencobra/COBRA.jl/tree/0d867c7d7dff7a60150da3f3408fdd0207335aae/docs/../src/solve.jl#L166-L194">source</a><br/></section><footer><hr/><a class="previous" href="configuration.html"><span class="direction">Previous</span><span class="title">Configuration</span></a><a class="next" href="faq.html"><span class="direction">Next</span><span class="title">FAQ</span></a></footer></article></body></html>
